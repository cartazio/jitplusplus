#include <iostream>
#include <jit++/decoder.h>
#include <jit++/common.h>

namespace {
    template <typename T> T fetch(int64_t & i) {
        T result = *reinterpret_cast<const T*>(i);
        i += sizeof(result);
        return result;
    }
}

namespace jitpp {
    const uint8_t decoder::encoding_lut[512] = {
	// xx
        0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00,  0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00, // 0x
	0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00,  0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00, // 1x
        0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00,  0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00, // 2x
	0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00,  0x80, 0x80, 0x80, 0x80,  0x01, 0x02, 0x00, 0x00, // 3x

        0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, // 4x
	0x10, 0x10, 0x10, 0x10,  0x10, 0x10, 0x10, 0x10,  0x10, 0x10, 0x10, 0x10,  0x10, 0x10, 0x10, 0x10, // 5x
        0x00, 0x00, 0x00, 0x80,  0x00, 0x00, 0x00, 0x00,  0x12, 0x80, 0x11, 0x80,  0x00, 0x00, 0x00, 0x00, // 6x
	0x11, 0x11, 0x11, 0x11,  0x11, 0x11, 0x11, 0x11,  0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, // 7x

        0x81, 0x82, 0x81, 0x81,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 8x
	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x10, 0x10, 0x00, 0x00, // 9x
        0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, // ax
	0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01,  0x05, 0x05, 0x05, 0x05,  0x05, 0x05, 0x05, 0x05, // bx

        0x81, 0x81, 0x10, 0x10,  0x00, 0x00, 0x81, 0x82,  0x14, 0x10, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, // cx
	0x80, 0x80, 0x80, 0x80,  0x00, 0x00, 0x00, 0x00,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // dx
        0x11, 0x11, 0x11, 0x11,  0x00, 0x00, 0x00, 0x00,  0x12, 0x12, 0x00, 0x11,  0x00, 0x00, 0x00, 0x00, // ex
	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x86, 0x86,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x80, 0x90, // fx

        0x80, 0x80, 0x80, 0x80,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x80, 0x00, 0x80, // 0f 0x
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f 1x
        0x80, 0x80, 0x80, 0x80,  0xe0, 0xe1, 0x00, 0x00,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f 2x
	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0xc0, 0x00, 0xc1, 0x00,  0x00, 0x00, 0x00, 0x00, // 0f 3x

        0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f 4x
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f 5x
        0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f 6x
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x00,  0x00, 0x00, 0xc0, 0xc1,  0x80, 0x80, 0x80, 0x80, // 0f 7x

        0x02, 0x02, 0x02, 0x02,  0x02, 0x02, 0x02, 0x02,  0x02, 0x02, 0x02, 0x02,  0x02, 0x02, 0x02, 0x02, // 0f 8x // JCC Jz
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f 9x
        0x00, 0x00, 0x00, 0x80,  0x80, 0x80, 0x00, 0x00,  0x00, 0x00, 0x00, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f ax
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f bx

        0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, // 0f cx
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f dx
        0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80, // 0f ex
	0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x80,  0x80, 0x80, 0x80, 0x00  // 0f fx
    };

    int64_t decoder::parse(int64_t i) {
	parts = prefix = seg_prefix = sse_prefix = 0;
    refetch:
        code = fetch<uint8_t>(i);
	VLOG(4) << "opcode = " << std::hex << (int)code;

        switch (code) {
        case 0x0f: // 0f xx
            code = 0x100 | fetch<uint8_t>(i);
            break;
        case 0x26: case 0x2e: // es, cs
	case 0x36: case 0x3e: // ss, ds
	case 0x64: case 0x65: // fs, gs
            prefix &= prefix_legacy_mask;
            seg_prefix = code;
            goto refetch;
        case 0x40: case 0x41: case 0x42: case 0x43:
	case 0x44: case 0x45: case 0x46: case 0x47:
        case 0x48: case 0x49: case 0x4a: case 0x4b:
	case 0x4c: case 0x4d: case 0x4e: case 0x4f: // rex
            prefix |= code & prefix_rex_mask;
            goto refetch;
        case 0x66: // os
            prefix &= 0xf0;
	    if (!sse_prefix) sse_prefix = 1;
            prefix |= prefix_66h_mask;
            goto refetch;
        case 0x67: // as
            prefix &= prefix_legacy_mask;
            prefix |= prefix_67h_mask;
            goto refetch;
        case 0xf0: // lock
            prefix &= prefix_legacy_mask;
            prefix |= prefix_lock_mask;
            goto refetch;
	case 0xf2: // repne
	case 0xf3: // rep
	    sse_prefix = code & 3;
	    prefix &= prefix_legacy_mask;
	    prefix |= prefix_repxx_mask;
	    goto refetch;
        default:
            break;
        }
        uint8_t encoding_flags = encoding_lut[code];
	parts |= encoding_flags & (encoding_has_modrm | encoding_extra_byte | encoding_drex_byte);
        if (has_modrm()) { 
	    // read extra byte if needed
	    if (unlikely(has_extra())) {
		extra = fetch<uint8_t>(i);
		VLOG(4) << "extra = " << std::hex << (int)extra;
	    }
	    // parse mod r/m
	    uint8_t modrm = fetch<uint8_t>(i);
	    mod = modrm >> 6;
	    reg = rex_r((modrm >> 3) & 7);
	    uint8_t base_or_rm = rm = rex_b(modrm & 7);
	
	    VLOG(4) << "modrm = " << std::hex << (int)modrm << ", mod = " << (int)mod << ", reg.r = " << (int)reg << ", rm.b = " << (int)rm;
	    if ((mod != 3) && ((rm & 7) == 4)) {
		// read sib
                uint8_t sib = fetch<uint8_t>(i);
	        VLOG(4) << "sib = " << std::hex << (int)sib;
		parts |= part_sib;
		// read drex if needed
		// parse sib
                log_scale = sib >> 6;
                index = rex_x((sib >> 3) & 7);
                base_or_rm = base = rex_b(sib & 7);
	        VLOG(4) << std::hex << "log_scale = " << (int)log_scale << ", index.x = " << (int)index << ", base.b = " << (int)base;
	    }
	    if (unlikely(has_drex())) { 
		drex = fetch<uint8_t>(i);
		VLOG(4) << "drex = " << std::hex << (int)drex;
	    }
	    // read displacement
            switch (mod) {
            case 0: 
	 	if ((base_or_rm & 7) == 5) {
		    disp = fetch<int32_t>(i);
		    parts |= part_disp;
		} else disp = 0; 
		break;
            case 1: 
		disp = fetch<int8_t>(i); 
		parts |= part_disp;
		break;
            case 2: 
		disp = fetch<int32_t>(i); 
		parts |= part_disp;
		break;
	    case 3:
		disp = 0;
		break;
	    }
	    if ((parts & part_disp) != 0)
		VLOG(4) << "disp = " << std::hex << (int)disp;
	}

	if (has_rex_w()) log_v = 3;
	else if (has_os_prefix()) log_v = 1;
	else if ((encoding_flags & encoding_default_os_64) != 0) {
	    if (unlikely(code == 0xff))
		switch (reg) { 
		case 2: case 4: case 6: log_v = 3; break; // CALL Ev, JMP Ev, PUSH Ev
		default: log_v = 2;
		}
	    else if (unlikely((code == 0x8f) && (reg != 0))) log_v = 2; // any 8f /n (n != 0) than POP Ev
	    else log_v = 3;
	} else log_v = 2;

	VLOG(4) << "immediate form = " << (int)(encoding_flags & encoding_immediate_mask);
    retry_imm:
	switch (encoding_flags & encoding_immediate_mask) {
	case encoding_no_imm:
	    imm = 0;
	    break;
	case encoding_Ib:
	    imm = fetch<int8_t>(i);
	    parts |= part_imm;
	    break;
	case encoding_Iz: 
	    imm = (log_v == 1) ? fetch<int16_t>(i) : fetch<int32_t>(i);
	    parts |= part_imm;
	    break;
	case encoding_Iw: 
	    imm = fetch<int16_t>(i); 
	    parts |= part_imm;
	    break;
	case encoding_IwIb:
	    imm = fetch<int16_t>(i);
	    imm2 = fetch<int8_t>(i);
	    parts |= (part_imm | part_imm2);
	    break;
	case encoding_Iv:
	    switch (log_v) { 
	    case 1: imm = fetch<int16_t>(i); break;
	    case 2: imm = fetch<int32_t>(i); break;
	    case 3: imm = fetch<int64_t>(i); break;
	    }
	    break;
	case encoding_hard:
	    switch (code) { 
	    case 0xf6: 
		if ((reg & 6) == 0) {
		    imm = fetch<int8_t>(i);
	            parts |= part_imm;
		} else imm = 0;
		break;
	    case 0xf7: 
		if ((reg & 6) == 0) { 
		    imm = (log_v == 1) ? fetch<int16_t>(i) : fetch<int32_t>(i); // Iz
		    parts |= part_imm;
		} else imm = 0;
		break;
	    default:
		LOG(DFATAL) << "hard immediate without case. opcode: " << std::hex << (int)code;
		code = 0x10b; // bail by invoking known bad opcode UD1 
		imm = 0;
		break;
	    }
	    break;
	default: 
	    LOG(DFATAL) << "unknown immediate encoding " << (int)(encoding_flags & encoding_immediate_mask);
	    code = 0x10b;
	    imm = 0;
	    break;
	}
	if ((parts & part_imm) != 0)
	    VLOG(4) << "imm = " << std::hex << (int)imm;
	return i;
    }
}
